<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xmlns:x86="http://www.felixcloutier.com/x86"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="stylesheet" type="text/css" href="style.css"/><a class="dashingAutolink" name="autolink-118"></a><a class="dashAnchor" name="//apple_ref/cpp/Instruction/EENTER"></a><title>EENTER</title></head><body><header><nav><ul><li><a href="index.html">Index</a></li><li>May 2019</li></ul></nav></header><h1>EENTER
		&mdash; Enters an Enclave</h1>

<table>
<tbody><tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>EAX = 02H ENCLU[EENTER]</td>
<td>IR</td>
<td>V/V</td>
<td>SGX1</td>
<td>This leaf function is used to enter an enclave.</td></tr></tbody></table>
<h2 id="instruction-operand-encoding">Instruction Operand Encoding<a class="anchor" href="EENTER.html#instruction-operand-encoding">
			&para;
		</a></h2>
<table>
<tbody><tr>
<td>Op/En</td>
<td colspan="2">EAX</td>
<td>RBX</td>
<td colspan="2">RCX</td></tr>
<tr>
<td>IR</td>
<td>EENTER (In)</td>
<td>Content of RBX.CSSA (Out)</td>
<td>Address of a TCS (In)</td>
<td>Address of AEP (In)</td>
<td>Address of IP following EENTER (Out)</td></tr></tbody></table>
<h3 id="description">Description<a class="anchor" href="EENTER.html#description">
			&para;
		</a></h3>
<p>The ENCLU[EENTER] instruction transfers execution to an enclave. At the end of the instruction, the logical processor is executing in enclave mode at the RIP computed as EnclaveBase + TCS.OENTRY. If the target address is not within the CS segment (32-bit) or is not canonical (64-bit), a #GP(0) results.</p>
<h2 id="eenter-memory-parameter-semantics">EENTER Memory Parameter Semantics<a class="anchor" href="EENTER.html#eenter-memory-parameter-semantics">
			&para;
		</a></h2>
<table>
<tbody><tr>
<td>TCS</td></tr>
<tr>
<td>Enclave access</td></tr></tbody></table>
<p>EENTER is a serializing instruction. The instruction faults if any of the following occurs:</p>
<table>
<tbody><tr>
<td>Address in RBX is not properly aligned.</td>
<td>Any TCS.FLAGS&rsquo;s must-be-zero bit is not zero.</td></tr>
<tr>
<td>TCS pointed to by RBX is not valid or available or locked.</td>
<td>Current 32/64 mode does not match the enclave mode in SECS.ATTRIBUTES.MODE64.</td></tr>
<tr>
<td>The SECS is in use.</td>
<td>Either of TCS-specified FS and GS segment is not a subsets of the current DS segment.</td></tr>
<tr>
<td>Any one of DS, ES, CS, SS is not zero.</td>
<td>If XSAVE available, CR4.OSXSAVE = 0, but SECS.ATTRIBUTES.XFRM ≠ 3.</td></tr>
<tr>
<td>CR4.OSFXSR ≠ 1.</td>
<td>If CR4.OSXSAVE = 1, SECS.ATTRIBUTES.XFRM is not a subset of XCR0.</td></tr></tbody></table>
<p>The following operations are performed by EENTER:</p>
<ul>
<li>RSP and RBP are saved in the current SSA frame on EENTER and are automatically restored on EEXIT or interrupt.</li>
<li>The AEP contained in RCX is stored into the TCS for use by AEXs.FS and GS (including hidden portions) are saved and new values are constructed using TCS.OFSBASE/GSBASE (32 and 64-bit mode) and TCS.OFSLIMIT/GSLIMIT (32-bit mode only). The resulting segments must be a subset of the DS segment.</li>
<li>If CR4.OSXSAVE == 1, XCR0 is saved and replaced by SECS.ATTRIBUTES.XFRM. The effect of RFLAGS.TF depends on whether the enclave entry is opt-in or opt-out (see Section 42.1.2):
<ul>
<li>On opt-out entry, TF is saved and cleared (it is restored on EEXIT or AEX). Any attempt to set TF via a POPF instruction while inside the enclave clears TF (see Section 42.2.5).</li>
<li>On opt-out entry, TF is saved and cleared (it is restored on EEXIT or AEX). Any attempt to set TF via a POPF instruction while inside the enclave clears TF (see Section 42.2.5).</li>
<li>On opt-in entry, a single-step debug exception is pended on the instruction boundary immediately after EENTER (see Section 42.2.2).</li>
<li>On opt-in entry, a single-step debug exception is pended on the instruction boundary immediately after EENTER (see Section 42.2.2).</li></ul></li>
<li>All code breakpoints that do not overlap with ELRANGE are also suppressed. If the entry is an opt-out entry, all code and data breakpoints that overlap with the ELRANGE are suppressed.</li>
<li>On opt-out entry, a number of performance monitoring counters and behaviors are modified or suppressed (see Section 42.2.3):
<ul>
<li>All performance monitoring activity on the current thread is suppressed except for incrementing and firing of FIXED_CTR1 and FIXED_CTR2.</li>
<li>All performance monitoring activity on the current thread is suppressed except for incrementing and firing of FIXED_CTR1 and FIXED_CTR2.</li>
<li>PEBS is suppressed.</li>
<li>PEBS is suppressed.</li>
<li>AnyThread counting on other threads is demoted to MyThread mode and IA32_PERF_GLOBAL_STATUS[60] on that thread is set</li>
<li>AnyThread counting on other threads is demoted to MyThread mode and IA32_PERF_GLOBAL_STATUS[60] on that thread is set</li>
<li>If the opt-out entry on a hardware thread results in suppression of any performance monitoring, then the processor sets IA32_PERF_GLOBAL_STATUS[60] and IA32_PERF_GLOBAL_STATUS[63].</li>
<li>If the opt-out entry on a hardware thread results in suppression of any performance monitoring, then the processor sets IA32_PERF_GLOBAL_STATUS[60] and IA32_PERF_GLOBAL_STATUS[63].</li></ul></li></ul>
<h3 id="concurrency-restrictions">Concurrency Restrictions<a class="anchor" href="EENTER.html#concurrency-restrictions">
			&para;
		</a></h3>
<figure id="tbl-40-60">
<table>
<tbody><tr>
<th rowspan="2">Leaf</th>
<th rowspan="2">Parameter</th>
<th colspan="3">Base Concurrency Restrictions</th></tr>
<tr>
<th>Access</th>
<th>On Conflict</th>
<th>SGX_CONFLICT VM Exit Qualification</th></tr>
<tr>
<td>EENTER</td>
<td>TCS [DS:RBX]</td>
<td>Shared</td>
<td>#GP</td>
<td></td></tr></tbody></table>
<figcaption><span class="not-imported">Table 40-60</span>. Base Concurrency Restrictions of EENTER</figcaption></figure>
<figure id="tbl-40-61">
<table>
<tbody><tr>
<th rowspan="3">Leaf</th>
<th rowspan="3">Parameter</th>
<th colspan="6">Additional Concurrency Restrictions</th></tr>
<tr>
<th colspan="2">vs. EACCEPT, EACCEPTCOPY, EMODPE, EMODPR, EMODT</th>
<th colspan="2">vs. EADD, EEXTEND, EINIT</th>
<th colspan="2">vs. ETRACK, ETRACKC</th></tr>
<tr>
<th>Access</th>
<th>On Conflict</th>
<th>Access</th>
<th>On Conflict</th>
<th>Access</th>
<th>On Conflict</th></tr>
<tr>
<td>EENTER</td>
<td>TCS [DS:RBX]</td>
<td>Concurrent</td>
<td></td>
<td>Concurrent</td>
<td></td>
<td>Concurrent</td>
<td></td></tr></tbody></table>
<figcaption><span class="not-imported">Table 40-61</span>. Additional Concurrency Restrictions of EENTER</figcaption></figure>
<h3 id="operation">Operation<a class="anchor" href="EENTER.html#operation">
			&para;
		</a></h3>
<h2 id="temp-variables-in-eenter-operational-flow">Temp Variables in EENTER Operational Flow<a class="anchor" href="EENTER.html#temp-variables-in-eenter-operational-flow">
			&para;
		</a></h2>
<table>
<tbody><tr>
<th>Name</th>
<th>Type</th>
<th>Size (Bits)</th>
<th>Description</th></tr>
<tr>
<td>TMP_FSBASE</td>
<td>Effective Address</td>
<td>32/64</td>
<td>Proposed base address for FS segment.</td></tr>
<tr>
<td>TMP_GSBASE</td>
<td>Effective Address</td>
<td>32/64</td>
<td>Proposed base address for FS segment.</td></tr>
<tr>
<td>TMP_FSLIMIT</td>
<td>Effective Address</td>
<td>32/64</td>
<td>Highest legal address in proposed FS segment.</td></tr>
<tr>
<td>TMP_GSLIMIT</td>
<td>Effective Address</td>
<td>32/64</td>
<td>Highest legal address in proposed GS segment.</td></tr>
<tr>
<td>TMP_XSIZE</td>
<td>integer</td>
<td>64</td>
<td>Size of XSAVE area based on SECS.ATTRIBUTES.XFRM.</td></tr>
<tr>
<td>TMP_SSA_PAGE</td>
<td>Effective Address</td>
<td>32/64</td>
<td>Pointer used to iterate over the SSA pages in the current frame.</td></tr>
<tr>
<td>TMP_GPR</td>
<td>Effective Address</td>
<td>32/64</td>
<td>Address of the GPR area within the current SSA frame.</td></tr></tbody></table>
<p>TMP_MODE64&larr;((IA32_EFER.LMA = 1) &amp;&amp; (CS.L = 1));</p>
<p>(* Make sure DS is usable, expand up *)</p>
<p>IF (TMP_MODE64 = 0 and (DS not usable or ( ( DS[S] = 1) and (DS[bit 11] = 0) and DS[bit 10] = 1) ) )</p>
<p>THEN #GP(0); FI;</p>
<p>(* Check that CS, SS, DS, ES.base is 0 *)</p>
<p>IF (TMP_MODE64 = 0)</p>
<p>THEN</p>
<p>IF(CS.base ≠ 0 or DS.base ≠ 0) #GP(0); FI;</p>
<p>IF(ES usable and ES.base ≠ 0) #GP(0); FI;</p>
<p>IF(SS usable and SS.base ≠ 0) #GP(0); FI;</p>
<p>IF(SS usable and SS.B = 0) #GP(0); FI;</p>
<p>FI;</p>
<p>IF (DS:RBX is not 4KByte Aligned)</p>
<p>THEN #GP(0); FI;</p>
<p>IF (DS:RBX does not resolve within an EPC)</p>
<p>THEN #PF(DS:RBX); FI;</p>
<p>(* Check AEP is canonical*)</p>
<p>IF (TMP_MODE64 = 1 and (CS:RCX is not canonical) )</p>
<p>THEN #GP(0); FI;</p>
<p>(* Check concurrency of TCS operation*)</p>
<p>IF (Other Intel SGX instructions is operating on TCS)</p>
<p>THEN #GP(0); FI;</p>
<p>(* TCS verification *)</p>
<p>IF (EPCM(DS:RBX).VALID = 0)</p>
<p>THEN #PF(DS:RBX); FI;</p>
<p>IF (EPCM(DS:RBX).BLOCKED = 1)</p>
<p>THEN #PF(DS:RBX); FI;</p>
<p>IF ( (EPCM(DS:RBX).ENCLAVEADDRESS ≠ DS:RBX) or (EPCM(DS:RBX).PT ≠ PT_TCS) )</p>
<p>THEN #PF(DS:RBX); FI;</p>
<p>IF ((EPCM(DS:RBX).PENDING = 1) or (EPCM(DS:RBX).MODIFIED = 1))</p>
<p>THEN #PF(DS:RBX); FI;</p>
<p>IF ( (DS:RBX).OSSA is not 4KByte Aligned)</p>
<p>THEN #GP(0); FI;</p>
<p>(* Check proposed FS and GS *)</p>
<p>IF ( ( (DS:RBX).OFSBASE is not 4KByte Aligned) or ( (DS:RBX).OGSBASE is not 4KByte Aligned) )</p>
<p>THEN #GP(0); FI;</p>
<p>(* Get the SECS for the enclave in which the TCS resides *)</p>
<p>TMP_SECS&larr;Address of SECS for TCS;</p>
<p>(* Check proposed FS/GS segments fall within DS *)</p>
<p>IF (TMP_MODE64 = 0)</p>
<p>THEN</p>
<p>TMP_FSBASE&larr;(DS:RBX).OFSBASE + TMP_SECS.BASEADDR;</p>
<p>TMP_FSLIMIT&larr;(DS:RBX).OFSBASE + TMP_SECS.BASEADDR + (DS:RBX).FSLIMIT;</p>
<p>TMP_GSBASE&larr;(DS:RBX).OGSBASE + TMP_SECS.BASEADDR;</p>
<p>TMP_GSLIMIT&larr;(DS:RBX).OGSBASE + TMP_SECS.BASEADDR + (DS:RBX).GSLIMIT;</p>
<p>(* if FS wrap-around, make sure DS has no holes*)</p>
<p>IF (TMP_FSLIMIT &lt; TMP_FSBASE)</p>
<p>THEN</p>
<p>IF (DS.limit &lt; 4GB) THEN #GP(0); FI;</p>
<p>ELSE</p>
<p>IF (TMP_FSLIMIT &gt; DS.limit) THEN #GP(0); FI;</p>
<p>FI;</p>
<p>(* if GS wrap-around, make sure DS has no holes*)</p>
<p>IF (TMP_GSLIMIT &lt; TMP_GSBASE)</p>
<p>THEN</p>
<p>IF (DS.limit &lt; 4GB) THEN #GP(0); FI;</p>
<p>ELSE</p>
<p>IF (TMP_GSLIMIT &gt; DS.limit) THEN #GP(0); FI;</p>
<p>FI;</p>
<p>ELSE</p>
<p>TMP_FSBASE&larr;(DS:RBX).OFSBASE + TMP_SECS.BASEADDR;</p>
<p>TMP_GSBASE&larr;(DS:RBX).OGSBASE + TMP_SECS.BASEADDR;</p>
<p>IF ( (TMP_FSBASE is not canonical) or (TMP_GSBASE is not canonical))</p>
<p>THEN #GP(0); FI;</p>
<p>FI;</p>
<p>(* Ensure that the FLAGS field in the TCS does not have any reserved bits set *)</p>
<p>IF ( ( (DS:RBX).FLAGS &amp; FFFFFFFFFFFFFFFEH) ≠ 0)</p>
<p>THEN #GP(0); FI;</p>
<p>(* SECS must exist and enclave must have previously been EINITted *)</p>
<p>IF (the enclave is not already initialized)</p>
<p>THEN #GP(0); FI;</p>
<p>(* make sure the logical processor&rsquo;s operating mode matches the enclave *)</p>
<p>IF ( (TMP_MODE64 ≠ TMP_SECS.ATTRIBUTES.MODE64BIT) )</p>
<p>THEN #GP(0); FI;</p>
<p>IF (CR4.OSFXSR = 0)</p>
<p>THEN #GP(0); FI;</p>
<p>(* Check for legal values of SECS.ATTRIBUTES.XFRM *)</p>
<p>IF (CR4.OSXSAVE = 0)</p>
<p>THEN</p>
<p>IF (TMP_SECS.ATTRIBUTES.XFRM ≠ 03H) THEN #GP(0); FI;</p>
<p>ELSE</p>
<p>IF ( (TMP_SECS.ATTRIBUTES.XFRM &amp; XCR0) ≠ TMP_SECS.ATTRIBUES.XFRM) THEN #GP(0); FI;</p>
<p>FI;</p>
<p>(* Make sure the SSA contains at least one more frame *) IF ( (DS:RBX).CSSA &ge; (DS:RBX).NSSA) THEN #GP(0); FI;</p>
<p>(* Compute linear address of SSA frame *)</p>
<p>TMP_SSA&larr;(DS:RBX).OSSA + TMP_SECS.BASEADDR + 4096 * TMP_SECS.SSAFRAMESIZE * (DS:RBX).CSSA;</p>
<p>TMP_XSIZE &larr; compute_XSAVE_frame_size(TMP_SECS.ATTRIBUTES.XFRM);</p>
<p>FOR EACH TMP_SSA_PAGE = TMP_SSA to TMP_SSA + TMP_XSIZE</p>
<p>(* Check page is read/write accessible *)</p>
<p>Check that DS:TMP_SSA_PAGE is read/write accessible;</p>
<p>If a fault occurs, release locks, abort and deliver that fault;</p>
<p>IF (DS:TMP_SSA_PAGE does not resolve to EPC page)</p>
<p>THEN #PF(DS:TMP_SSA_PAGE); FI;</p>
<p>IF (EPCM(DS:TMP_SSA_PAGE).VALID = 0)</p>
<p>THEN #PF(DS:TMP_SSA_PAGE); FI;</p>
<p>IF (EPCM(DS:TMP_SSA_PAGE).BLOCKED = 1)</p>
<p>THEN #PF(DS:TMP_SSA_PAGE); FI;</p>
<p>IF ((EPCM(DS:TMP_SSA_PAGE).PENDING = 1) or (EPCM(DS:TMP_SSA_PAGE).MODIFIED = 1))</p>
<p>THEN #PF(DS:TMP_SSA_PAGE); FI;</p>
<p>IF ( ( EPCM(DS:TMP_SSA_PAGE).ENCLAVEADDRESS ≠ DS:TMP_SSA_PAGE) or (EPCM(DS:TMP_SSA_PAGE).PT ≠ PT_REG) or</p>
<p>(EPCM(DS:TMP_SSA_PAGE).ENCLAVESECS ≠ EPCM(DS:RBX).ENCLAVESECS) or</p>
<p>(EPCM(DS:TMP_SSA_PAGE).R = 0) or (EPCM(DS:TMP_SSA_PAGE).W = 0) )</p>
<p>THEN #PF(DS:TMP_SSA_PAGE); FI;</p>
<p>CR_XSAVE_PAGE_n &larr; Physical_Address(DS:TMP_SSA_PAGE);</p>
<p>ENDFOR</p>
<p>(* Compute address of GPR area*)</p>
<p>TMP_GPR&larr;TMP_SSA + 4096 * DS:TMP_SECS.SSAFRAMESIZE - sizeof(GPRSGX_AREA);</p>
<p>If a fault occurs; release locks, abort and deliver that fault;</p>
<p>IF (DS:TMP_GPR does not resolve to EPC page)</p>
<p>THEN #PF(DS:TMP_GPR); FI;</p>
<p>IF (EPCM(DS:TMP_GPR).VALID = 0)</p>
<p>THEN #PF(DS:TMP_GPR); FI;</p>
<p>IF (EPCM(DS:TMP_GPR).BLOCKED = 1)</p>
<p>THEN #PF(DS:TMP_GPR); FI;</p>
<p>IF ((EPCM(DS:TMP_GPR).PENDING = 1) or (EPCM(DS:TMP_GPR).MODIFIED = 1))</p>
<p>THEN #PF(DS:TMP_GPR); FI;</p>
<p>IF ( ( EPCM(DS:TMP_GPR).ENCLAVEADDRESS ≠ DS:TMP_GPR) or (EPCM(DS:TMP_GPR).PT ≠ PT_REG) or</p>
<p>(EPCM(DS:TMP_GPR).ENCLAVESECS EPCM(DS:RBX).ENCLAVESECS) or</p>
<p>(EPCM(DS:TMP_GPR).R = 0) or (EPCM(DS:TMP_GPR).W = 0) )</p>
<p>THEN #PF(DS:TMP_GPR); FI;</p>
<p>IF (TMP_MODE64 = 0)</p>
<p>THEN</p>
<p>IF (TMP_GPR + (GPR_SIZE -1) is not in DS segment) THEN #GP(0); FI;</p>
<p>FI;</p>
<p>CR_GPR_PA&larr;Physical_Address (DS: TMP_GPR);</p>
<p>(* Validate TCS.OENTRY *)</p>
<p>TMP_TARGET&larr;(DS:RBX).OENTRY + TMP_SECS.BASEADDR;</p>
<p>IF (TMP_MODE64 = 1)</p>
<p>THEN</p>
<p>IF (TMP_TARGET is not canonical) THEN #GP(0); FI;</p>
<p>ELSE</p>
<p>IF (TMP_TARGET &gt; CS limit) THEN #GP(0); FI;</p>
<p>FI;</p>
<p>(* Ensure the enclave is not already active and this thread is the only one using the TCS*)</p>
<p>IF (DS:RBX.STATE = ACTIVE)</p>
<p>THEN #GP(0); FI;</p>
<p>CR_ENCLAVE_MODE &larr; 1;</p>
<p>CR_ACTIVE_SECS &larr; TMP_SECS;</p>
<p>CR_ELRANGE&larr;(TMPSECS.BASEADDR, TMP_SECS.SIZE);</p>
<p>(* Save state for possible AEXs *)</p>
<p>CR_TCS_PA&larr;Physical_Address (DS:RBX);</p>
<p>CR_TCS_LA &larr; RBX;</p>
<p>CR_TCS_LA.AEP &larr; RCX;</p>
<p>(* Save the hidden portions of FS and GS *)</p>
<p>CR_SAVE_FS_selector &larr; FS.selector;</p>
<p>CR_SAVE_FS_base &larr; FS.base;</p>
<p>CR_SAVE_FS_limit &larr; FS.limit;</p>
<p>CR_SAVE_FS_access_rights &larr; FS.access_rights;</p>
<p>CR_SAVE_GS_selector &larr; GS.selector;</p>
<p>CR_SAVE_GS_base &larr; GS.base;</p>
<p>CR_SAVE_GS_limit &larr; GS.limit;</p>
<p>CR_SAVE_GS_access_rights &larr; GS.access_rights;</p>
<p>(* If XSAVE is enabled, save XCR0 and replace it with SECS.ATTRIBUTES.XFRM*)</p>
<p>IF (CR4.OSXSAVE = 1)</p>
<p>CR_SAVE_XCR0 &larr; XCR0;</p>
<p>XCR0 &larr; TMP_SECS.ATTRIBUTES.XFRM;</p>
<p>FI;</p>
<p>RCX &larr; RIP;</p>
<p>RIP &larr; TMP_TARGET;</p>
<p>RAX &larr; (DS:RBX).CSSA;</p>
<p>(* Save the outside RSP and RBP so they can be restored on interrupt or EEXIT *)</p>
<p>DS:TMP_SSA.U_RSP &larr; RSP;</p>
<p>DS:TMP_SSA.U_RBP &larr; RBP;</p>
<p>(* Do the FS/GS swap *)</p>
<p>FS.base &larr; TMP_FSBASE;</p>
<p>FS.limit &larr; DS:RBX.FSLIMIT;</p>
<p>FS.type &larr; 0001b;</p>
<p>FS.W &larr; DS.W;</p>
<p>FS.S &larr; 1;</p>
<p>FS.DPL &larr; DS.DPL;</p>
<p>FS.G &larr; 1;</p>
<p>FS.B &larr; 1;</p>
<p>FS.P &larr; 1;</p>
<p>FS.AVL &larr; DS.AVL;</p>
<p>FS.L &larr; DS.L;</p>
<p>FS.unusable &larr; 0;</p>
<p>FS.selector &larr; 0BH;</p>
<p>GS.base &larr; TMP_GSBASE;</p>
<p>GS.limit &larr; DS:RBX.GSLIMIT;</p>
<p>GS.type &larr; 0001b;</p>
<p>GS.W &larr; DS.W;</p>
<p>GS.S &larr; 1;</p>
<p>GS.DPL &larr; DS.DPL;</p>
<p>GS.G &larr; 1;</p>
<p>GS.B &larr; 1;</p>
<p>GS.P &larr; 1;</p>
<p>GS.AVL &larr; DS.AVL;</p>
<p>GS.L &larr; DS.L;</p>
<p>GS.unusable &larr; 0;</p>
<p>GS.selector &larr; 0BH;</p>
<p>CR_DBGOPTIN &larr; TCS.FLAGS.DBGOPTIN;</p>
<p>Suppress_all_code_breakpoints_that_are_outside_ELRANGE;</p>
<p>IF (CR_DBGOPTIN = 0)</p>
<p>THEN</p>
<p>Suppress_all_code_breakpoints_that_overlap_with_ELRANGE;</p>
<p>CR_SAVE_TF &larr; RFLAGS.TF;</p>
<p>RFLAGS.TF &larr; 0;</p>
<p>Suppress_monitor_trap_flag for the source of the execution of the enclave;</p>
<p>Suppress any pending debug exceptions;</p>
<p>Suppress any pending MTF VM exit;</p>
<p>ELSE</p>
<p>IF RFLAGS.TF = 1</p>
<p>THEN pend a single-step #DB at the end of EENTER; FI;</p>
<p>IF the &ldquo;monitor trap flag&rdquo; VM-execution control is set</p>
<p>THEN pend an MTF VM exit at the end of EENTER; FI;</p>
<p>FI;</p>
<p>Flush_linear_context;</p>
<p>Allow_front_end_to_begin_fetch_at_new_RIP;</p>
<h3 id="flags-affected">Flags Affected<a class="anchor" href="EENTER.html#flags-affected">
			&para;
		</a></h3>
<p>RFLAGS.TF is cleared on opt-out entry</p>
<h3 class="exceptions" id="protected-mode-exceptions">Protected Mode Exceptions<a class="anchor" href="EENTER.html#protected-mode-exceptions">
			&para;
		</a></h3>
<table>
<tbody><tr>
<td rowspan="11">#GP(0)</td>
<td>If DS:RBX is not page aligned.</td></tr>
<tr>
<td>If the enclave is not initialized.</td></tr>
<tr>
<td>If part or all of the FS or GS segment specified by TCS is outside the DS segment or not properly aligned.</td></tr>
<tr>
<td>If the thread is not in the INACTIVE state.</td></tr>
<tr>
<td>If CS, DS, ES or SS bases are not all zero.</td></tr>
<tr>
<td>If executed in enclave mode.</td></tr>
<tr>
<td>If any reserved field in the TCS FLAG is set.</td></tr>
<tr>
<td>If the target address is not within the CS segment.</td></tr>
<tr>
<td>If CR4.OSFXSR = 0.</td></tr>
<tr>
<td>If CR4.OSXSAVE = 0 and SECS.ATTRIBUTES.XFRM ≠ 3.</td></tr>
<tr>
<td>If CR4.OSXSAVE = 1and SECS.ATTRIBUTES.XFRM is not a subset of XCR0.</td></tr>
<tr>
<td rowspan="3">#PF(error</td>
<td>code) If a page fault occurs in accessing memory.</td></tr>
<tr>
<td>If DS:RBX does not point to a valid TCS.</td></tr>
<tr>
<td>If one or more pages of the current SSA frame are not readable/writable, or do not resolve to a valid PT_REG EPC page.</td></tr></tbody></table>
<h3 class="exceptions" id="64-bit-mode-exceptions">64-Bit Mode Exceptions<a class="anchor" href="EENTER.html#64-bit-mode-exceptions">
			&para;
		</a></h3>
<table>
<tbody><tr>
<td rowspan="10">#GP(0)</td>
<td>If DS:RBX is not page aligned.</td></tr>
<tr>
<td>If the enclave is not initialized.</td></tr>
<tr>
<td>If the thread is not in the INACTIVE state.</td></tr>
<tr>
<td>If CS, DS, ES or SS bases are not all zero.</td></tr>
<tr>
<td>If executed in enclave mode.</td></tr>
<tr>
<td>If part or all of the FS or GS segment specified by TCS is outside the DS segment or not properly aligned.</td></tr>
<tr>
<td>If the target address is not canonical.</td></tr>
<tr>
<td>If CR4.OSFXSR = 0.</td></tr>
<tr>
<td>If CR4.OSXSAVE = 0 and SECS.ATTRIBUTES.XFRM ≠ 3.</td></tr>
<tr>
<td>If CR4.OSXSAVE = 1and SECS.ATTRIBUTES.XFRM is not a subset of XCR0.</td></tr>
<tr>
<td rowspan="3">#PF(error</td>
<td>code) If a page fault occurs in accessing memory operands.</td></tr>
<tr>
<td>If DS:RBX does not point to a valid TCS.</td></tr>
<tr>
<td>If one or more pages of the current SSA frame are not readable/writable, or do not resolve to a valid PT_REG EPC page.</td></tr></tbody></table><footer><p>
		This UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be
		inc<span style="opacity: 0.2">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious
		ways. Refer to <a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">Intel&reg; 64 and IA-32 Architectures Software Developer&rsquo;s Manual</a> for anything serious.
	</p></footer>
</body></html>